<!DOCTYPE html>
<html>
<head>
	<script type="text/x-mathjax-config">
  		MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
	</script>
	
	<script type="text/javascript" async
  		src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
	</script>
	
	
	<title>MathJax TeX Test Page</title>
</head>
<body>
<h1>Indice </h1>
<ul>
<li><a href="#nt">Notación</a> </li>
<li><a href="#inv">Invariantes y Asignación paralela</a> </li>
<li><a href="#it">Esquemas Iterativos</a> </li>
<li><a href="#j8">Esquemas equivalentes en Java 8 a los Esquemas Iterativos</a> </li>
<li><a href="#rc">Esquemas Recursivos</a> </li>
<li><a href="#itrc">Transformación Iterativo-Recursivo</a> </li>
<li><a href="#rcit">Transformación Recursivo-Iterativo</a> </li>
</ul>
<a id="nt"><h1> Notación </h1>
<ul>
  <li><strong>Rangos</strong>. Son secuencias de números enteros. Los representaremos por \([a,b), [a,b]\). 
El primero no incluye el extremo derecho el segundo si. </li>
 <li><strong>Tuplas</strong>. Son agregados inmutables de valores posiblemente de diferentes tipos. 
Las representaremos por \( (t_0,t_1,...,t_{r-1})\). Si \( t \) es una tupla \( t[i] \)
 representa el i-esimo elementos y \( |t| \) el número de elementos.</li>
  <li><strong>Listas</strong>. Son secuencias indexadas de elementos. Las representaremos por \( [e(x), x \in sq, \mbox{si }p(x)]\). 
Dónde \( e(x), p(x), sq \) son, respectivamente una expresión, un predicado y una secuencia. Si \( ls \) 
es una lista representaremos por \(ls[i]\) el elemento de la casilla \(i\),  por \(|ls|\) su longitud y por
\(ls[b,c]\) la sublista que va del índice \(a\) al \(b\) sin incluir este último.  </li>
  <li><strong>Conjuntos</strong>. Son agregados sin repetición de elementos. 
Las representaremos por \( \{e(x), x \in sq, \mbox{si }p(x)\}\). Si \( s \) 
es un conjunto representaremos por \(|s|\) su cardinal y por \( \{\} \) el conjunto vacío.</li>
<li><strong>Multiconjuntos</strong>. Son agregados con repetición de elementos. 
Las representaremos por \( \{e(x):n(x), x \in sq, \mbox{si }p(x)\}\). Con \( n(x) \) una expresión que devuelve un entero positivo o cero.
Si \( ms \) 
es un multiconjunto representaremos por \(ms[e]\) el número de veces que se repite 
\(e \) en \( ms \) y por \( \{\} \) el multiconjunto vacío.</li>
  <li><strong>Diccionarios</strong>. Son conjuntos de pares clave-valor dónde las claves no están repetidas. 
Las representaremos por \( \{c(x):v(x), x \in sq, \mbox{si }p(x)\}\). Dónde \( c(x), v(x) \) son expresiones.
Si \( d \) 
es un diccionario representaremos por \(d[c]\) el valor asociado a la clave \(c\), por \(d.keys, d.items\) 
el conjunto de sus claves y de sus pares clave-valor respectivamente y por \( \{\} \) un diccionario vacío. 
su longitud.</li>
  <li><strong>Secuencias</strong>. Son agregados de elementos que se pueden recorrer secuencialmente. Los rangos, 
las listas, los conjuntos, el conjunto de los pares de un diccionario y 
el conjunto de sus claves pueden ser convertidos a secuencias. Desde el punto de vista que nos interesa aquí, 
una secuencia básica puede especificarse mediante \( (e_0, s(e), p(e)) \) dónde los valores \( e_o, e \) 
son de un tipo \( E\). 
La secuencia tiene un estado, un valor del tipo \(E\), un valor inicial \(e_0\), para cada elemento tiene un elemento 
siguiente
\(s(e)\) y un predicado que deben cumplir todos los elementos de la secuencia. Las secuencias pueden ser dotadas de 
operaciones de filtro y transformación con las que es posible construir secuencias más complejas a partir de otras más simples. 
Esto lo indicaremos en al forma \( s = [t(x), x \in sq| f(x)] \). Donde \(t(x), f(x)\) son la transformación y
el filtro aplicados.
También podemos definir operaciones de acumulación que permiten, como su nombre indica, acumular los valores de la secuencia. </li>
</ul>
<a id="inv"><h1> Invariantes y Asignación Paralela </h1>
<h2>Bloque básico</h2>
<p>
En los lenguajes imperativos hay sentencias que producen un cambio del valor de una variable dada. 
La más usual es la sentencia de asignación. Una asignación se representa en la mayoría de los lenguajes de la forma:

\[ x=e(x,a); \]

Tenemos que recordar que una variable tiene dos aspectos que debemos tener en cuenta. 
Por una parte es una ubicación dónde se puede guardar un valor de un determinado tipo. 
Por otra parte es un valor que se guarda en dicha ubicación. 
La ubicación de la variable permanece fija pero el valor va cambiando a lo largo de la ejecución de un programa. 
Los sucesivos valores que una variable \( x \) va tomando los designaremos por \( x,x',x'',x''',… \) . 
Si la variable aparece en una expresión en la parte derecha de una asignación diremos que la estamos usando. Si parece en la parte izquierda
diremos que la estamos definiendo.
</p>
<p>
Llamaremos bloque básico a una secuencia de sentencias de asignación. 
Por tanto en un bloque básico no hay if ni while.  Un primer ejemplo de bloque básico es:
<code><pre>
a=x;
b=y;
x=b;
y=a;
</pre></code>

Otro segundo ejemplo es:
<code><pre>
a=x;
x=y;
y=a;
</pre></code>
Y un tercero:
<code><pre>
x=y;
a=x;
y=a;
</pre></code>

<p>
Una restricción entre varias variables es un predicado sobre las mismas. 
También se le suele llamara aserto. Un conjunto de restricciones es un conjunto de predicados relacionales (=, >=, ...) combinados con el operador lógico
and que no haremos explícito. 
Más adelante introduciremos adicionalmente el operador lógico or para construir restricciones mas complejas. 
Un ejemplo de conjunto de restricciones es el visto arriba:
<pre>
x'=y;y'=y;
</pre>

En este caso el conjunto de restricciones se compone de dos predicados de igualdad combinados, como hemos comentado, por el operador and. 
Los conjuntos de restricciones tienen propiedades completamente diferentes de la secuencia de asignaciones que forman un bloque básico. 
La primera propiedad importante es que el orden no importa en el conjunto de restricciones y sí en el bloque básico. 
Las asignaciones en un bloque básico tienen un orden que no se puede cambiar.
La segunda es que el conjunto de restricciones puede ser manipulado simbólicamente. 
Es decir podemos despejar una variable en una restricción de igualdad y sustituirla en el resto de las restricciones como solemos hacer en matemáticas. 
La sustitución simbólica de \( a \)  por \( y \) en la expresión \(e\) la representaremos por  \( e[a¦y] \). 
En un bloque básico no es posible la manipulación simbólica por los efectos laterales que va produciendo el operador de asignación. 
</p>

<p>

En un bloque básico podemos estar interesados en obtener una restricción entre los valores finales de 
un conjunto de variables con los valores iniciales de las mismas.
Designaremos un conjunto de variables 
como \( x=(x_1,x_2,…,x_m) \), por \( x_i'\) el valor de la variable \( x_i \) tras ejecutar un bloque de código y por \( x' \)
el valor final de todas ellas. La relación entre los valores finales y los iniciales la expresamos por un conjunto de restricciones entre ellos. 
Una forma de restricción es la igualdad. 
Usaremos el operador = para representar la igualdad entre valores.  
El operador = si es simétrico a diferencia del operador de asignación (=) 
que no lo es, como hemos dicho. 
El operador = representa la igualdad entre valores. 
Es decir representa lo mismo que el operador = en Java usado entre tipos básicos o .equals() 
usado entre tipos objeto. Cunado estamos usando restricciones el operadro = representa la igualdad. Cuando estemos usando bloques
básicos representa asignación.
</p>
<p>
Un bloque básico se puede transformar en un conjunto de restricciones de igualdad siguiendo las pautas siguientes:
<ul>
<li> Comenzamos con un conjunto de restricciones vacío. 
Cada vez que se define variable (está en la izquierda de una asignación) se crea un identificador nuevo, 
se renombran los usos posteriores de esa variable y se añade una restricción de igualdad al conjunto de restricciones.  
Las identificadores nuevos los representaremos por \( x',x'',x''',… \) </li>
</ul>
Veamos un ejemplo:

\[ b = x; x = y;  y = b; \]
\[ b' = x; x' = y; y' = b';\]

<p>
El primero es un bloque básico. En est el operador = representa asignación. El segundo es un conjunto de restricciones. 
Aqui el operador = representa la igualdad.
Es éste podemos despejar variables y sustituir. 
En el bloque básico no. En el conjunto de restricciones podemos despejar \( x',y' \) en función de \(x,y\)  
resultando el conjunto de restricciones \( x'=y;y'==x;\). 
Estas restricciones nos dan el resultado neto del bloque básico sobre los valores iniciales \(x,y\).
</p>
<p>
Dos bloques básicos son equivalentes si dan lugar al mismo conjunto de restricciones 
entre los valores iniciales y finales de las variables. 
Esto podemos usarlo para simplificar un bloque básico. Algunas simplificaciones son:

<ul>
<li> Eliminación de asignaciones y  variables intermedias. 
Si una variable es definida en un bloque básico, mediante la asignación \( u=e(z);\), podemos sustituir 
la variable \(u\) por \(e(z)\) en el segmento de bloque básico hasta la siguiente definición de \(u, z\) y 
eliminar la asignación.
La sustitución simbólica la representaremos por b[u¦e(z) ]. 
</li>
<li>
Una variable que se define y no se usa puede ser eliminada
</li>
<li>
Si una variable se define y se vuelve a definir antes de ser usada la primera asignación puede ser eliminada
</li>
<li>
Cambio de orden de asignaciones. Una secuencia de  asignaciones de la forma \( x=f(x,a);y=g(y,a);z=h(z,a); \) 
pueden ser cambiadas de orden. Eso ocurre si  las variables definidas \(x,y,z\) no son usadas 
en la definición del resto de variables.
</li>
<li>
Cambio de orden de asignaciones. Una secuencia de  asignaciones de la forma \( x=f(x,a);y=g(x,y,a); \) 
pueden ser cambiadas de orden haciendo la sustitución simbólica correspondiente. 
El bloque equivalente es \( y=g(f(x,a),y,a);x=f(x,a); \) 
</li>
</ul>

Veamos la simplificación del bloque básico siguiente:

\[ a = y; b = x; x = a;  y = b; \]
Se simplifica a:
\[ b = x; x = y; y = b;  \]
<p>	
En el primer bloque básico la variable \(a\) es definida en \(a=y;\). La variable
\(y\) se define en \(y = b;\). En el el segmento intermedio  se puede sutituir s[a|y] y eliminar la aignación a \(a\) y
la propia variable.
</p>
<h2> El operador de asignación paralela </h2>

Algunos lenguajes de programación cuentan con el denominado operador de asignación paralela. 
Con este operador se pueden llevar a cabo varias asignaciones en paralelo como \( (x,y) = (y,x); \).

El operador = es la asignación paralela. 
Es decir la asignación de los valores de una tupla de  expresiones a una tupla de variables. 
El efecto neto de la asignación paralela anterior es el conjunto de restricciones \( x'=y;y'=x;\). 
En un primer momento la notación puede ser confusa porque podemos darnos cuenta que la secuencia de asignaciones:
<pre>
x=y;
y=x;
</pre>

No consigue el efecto deseado. 
Es decir no es equivalente a una asignación paralela ya que da lugar al conjunto de restricciones \(x'=y;y'=y;\). 
En general el operador de asignación paralela tiene la forma: 
\[
(x_1,x_2,…,x_m)=(e_1 (x_1,x_2,…,x_m ),e_2 (x_1,x_2,…,x_m ),…,e_m (x_1,x_2,…,x_m ))

\]
Es conveniente conocer con detalle la forma de implementar este operador, 
su relación con las restricciones entre los valores de las variables antes y después de su ejecución 
y, también, su relación con los bloque básicos de código. Veamos cada uno de estos conceptos y sus relaciones.
<p>
<p>
Los valores posteriores de esas variables son \( x_i'=e_i (x_1,x_2,…,x_m); \). 

Es decir en una asignación paralela se toman los valores previos de cada una de las expresiones de la derecha,  
de forma independiente (paralela) se calculan los valores finales de cada una de las variables asignadas y se les asigna.
Por La propiedad anterior implica que la variables de la parte izquierda pueden reordenarse de cualquier 
manera siempre que se reordenen de la misma forma las expresiones de la derecha. 
</p>
<p>
Los lenguajes de programación usuales disponen de bloques básicos pero no de asignación paralela. 
Debemos aprender a convertir una asignación paralela en un bloque básico y viceversa. 
Las asignaciones paralelas son más cómodas cuando hablamos de esquemas algorítmicos.
</p>
<p>
Veamos ahora como conseguir un bloque básico equivalente a una asignación paralela. 
La idea general es usar variables nuevas, asignar a estas variables los valores de las expresiones, 
posteriormente asignar las nuevas variables a las antiguas y simplificar el bloque básico. El esquema es entonces:
\[
(x_1,x_2,…,x_m )=(e_1,e_2,…,e_m) \equiv a_1 = e_1; a_2 = e_2; …,a_m = e_m; x_1 = a_1; x_2 = a_2; …,x_m = a_m;
\]
Por ejemplo
\[
(x,y)=(y,x) \equiv a = y; b = x;x = a;y = b; \equiv b = x;x = y;y = b;
\]
<p>
En el tercer paso hemos eliminado la variable \(a\) y la ecuación donde se definía y 
hemos sustituido su uso por su valor en la ecuación que define la \(x\). 
Como podemos comprobar el operador de asignación paralela 
se reduce a un bloque básico formado por una secuencia de asignaciones, en cualquier orden, 
cuando cada variable definida no usa ninguna de las demás variables definidas. 
</p>
<p>
Por otra parte si las expresiones \(e_i\), y las correspondientes variables, pueden ser reordenada de tal forma que
\(e_i\) sólo dependa de las variables \(x_i, x_{i+1},...,x_m\) entonces 
la asignación paralela es equivalente al bolque básico:
\[
(x_1, x_2,…, x_m )=(e_1, e_2,…, e_m) \equiv x_1 = e_1; x_2 = e_2; …,x_m = e_m;
\]
Este último caso es posible cuanda en la definición de cada variables sólo aparecen variables no definidas.
<p>
Por último solo destacar que un conjunto de restricciones de iguadad se transforma de manera sencialla 
en una asignación paralela y ésta, como hemos visto antes, se puede transformar en un bloque básico.
</p>
<a id="it"><h1> Algoritmos Iterativos </h1>

Los algoritmos iterativos tienen la estructura general:

<pre>

f(x) {
	e = e_0(x);
	while(g(e)){
	   e = s(e);
	}
	return r(e);
}
</pre>
Una variante que veremos en algunos caso es:
<pre>

f(x) {
	e = e_0(x);
	while(g(e)){
	   if(p(e) break;
	   e = s(e);         
	}
	return r(e);
}
</pre>
Que es equivalente al anterior si sustituimos \(g(e)\) por \(g(e) \land !p(e)\). Ahora si tenemos un invariante \(I(e)\),
después de salir del bucle se cumple \((!g(e) \lor p(e)) \land I(e) \). 
<p>
Al valor \(e\) se le denomina estado y normalmente está constituido por una tupla de valores. Como vemos los algortimos
iterativos comienzan en un estado inicial cuyo valor puede depender de losm parámetros \(x\) que también suelen 
ser una tupla de valores. Mientras eque el estado cumpla una condición, la guarda \(g(e)\), el algoritmo pasa al estado siguiente
mendiante la función \(s(e)\). Cuando la guarda ya no se cumple el algoritmo devuelve \(r(e)\),
</p>
<p>
Para diseñar algoritmos iterativos tenemos que introducir dos conceptos: el Invariante y la Función de Cota (
también podemos decir Tamaño del Problema).
</p>
<ul>
<li> El invariante, \(I(e)\), es una restricción sobre los valores del estado que debe cumplirse al principio y al
final del cuerpo del while. Es decir debe cumplirse \(I(e_0), I(s(e)\). O visto de otra manera: asumiendo que se cumple 
\(I(e)\) demos comprobar que se cumple \(I(s(e))\).
</li>
<li> La función de cota, \(C(e,x)\), devuelve un entero y debe cumplir \(C(e',x) \lt C(e,x)\). Dónde \(e'\) es el valor del
estado al final del cuerpo del bucle. Es decir debe cumplir \(C(s(e),x) \lt C(e,x)\). 
</li>
</ul>
<p>
Las propiedades de la cota nos aseguran que el algoritmo acabará. Las propiedades del invariante nos aseguran que cuando el algoritmo
acabe se cumplirá \( I(e) \land !g(e) \), lo cual nos puede permitir deducir una restricción, \(R(r,x)\), 
entre los parámetros de entrada y los resultados. La llamaremos restricción entrada-salida. 
En muchos casos el camino para diseñar un algoritmo iterativo partirá
de la restricción \(R(r,x)\) y tras elegir el tipo \(E\) y un invariante sobre el mismo, \(I(e)\), buscaremos \(e_0, s(e), g(e)\).
Normalmente el estado \(e\) es una tupla de valores que debemos imaginar. A este paso de encontrar el estado se le denomina generalizar
el problema.
</p>
<p>
Veamos el diseño de un algoritmo iterativo para calcular el factorial de un entero \(n!\). Si r son los resultados y \(n\)
el parámetro de entrada la restricción entrada-salida que define el algoritmo es \(R(n,r) \equiv r = n! \).Para diseñar el algoritmo
escogemos un estado \(E = (i,a)\), un invariante \(I(i,a) \equiv a = i!\), una función de cota 
\(C(i,a,n) \equiv n-i\). Con esas decisiones tomadas el algoritmo 
resultante queda:
</p>
<pre>
f(n) {
	(i,a) = (0,1);
	while(i < n){
	   (i,a) = (i+1,a*(i+1));
	}
	return a;
}
</pre>
<p>
Como podemos ver el estado inicial cumple el invariante, \( 1 = 0!\). 
Al final del bucle, haciendo en el invariante, \(a = i!\), la sustitución simbólica asociada a \(s(e)\), 
tendremos \(a*i = (i+1)!\),  que podemos 
comprobar que es cierto. Para ello vemos \[ a*(i+1) = (i+1)! = (i+1)*i! \equiv a = i! \] Luego el invariante es cierto
al final del bucle si asumimos que es cierto al principio. 
Igualmente la función de cota al principio y al final del bucle cumple la condición requerida  \[ n -(i+1) = n-i-1 < n-i \]
</p>
<p>
La restricción entrada salida que podemos obtener es:

\begin{align}
R(r,n) & \equiv r = a \land a = i! \land !(i < n) \\
 & \equiv  r = a \land a = i! \land i = n \\
 & \equiv r = n! \\
\end{align}

<p>
Con lo visto anteriormente podemos concluir que los algoritmos iterativos pueden considerarse como secuencias especificadas por
\( e_0, s(x), g(x) \)
</p>
Como último paso podemos eliminar las tuplas y la asignación paralela para resultar:
<pre>
int factorial(n) {
	i = 0;
	a = 1;
	while(i < n){
	   i = i + 1;
	   a = a * i;
	}
	return a;
}
</pre>
La forma del cuerpo del bucle corresponde a la asiganción paralela porque su conjunto de restricciones asociada es:
\[ i' = i+1, a' = a * i' \equiv i' = i+1, a' = a * (i+1) \]
<h2> Ejemplos de diseño iterativo </h2>
Vamos a ver un par de ejemplos de diseño iterativo.  El primero será la búsqueda binaria. 
El segundo el conocido como la bandera holandesa.

<p>
El problema consiste en, dada una lista \( ls\) ordenada  con respecto a un orden, encontrar,si existe, 
la posición de un elemento dado o -1 si no lo encuentra. 
</p>
<p>
Partimos de la lista ordenada \(ls\) de tamaño \(n = |ls|\) y un elemento \(e\) a buscar. El primer paso
es escoger un estado. Es lo que llamamos generalizar el problema. Escogemos un estado representado por la tupla \( (i, j\) 
verificándose \( j \ge i, i,j \in [0,n) \). En segundo lugar escogemos un invariante:

\[( e \not \in ls[i,j] \land e \not \in ls) \lor ( e \in ls[i,j] \land e \in ls)\]. 
Es decir el elemento no está en la 
lista ni en al sublista \(ls[i,j]\) o si está pertenece a la sublista \(ls[i,j]\). El tamaño del problema (o la función de cota) será \( j-i\).
</p>
<p>
El segundo paso es escoger el estado inicial, la guarda y la función siguiente para que se mantega el invariante y 
la función de cota cumpla las propiedades exigidas. 
</p>
Escogemos como función siguiente:
\[s(i,j) =
\begin{cases}
(i,k), & \text{si } e < ls[k] \\
(k,j), & \text{si } e > ls[k]
\end{cases}
\]
Con \( k = (i+j)/2 \). Con esos elementos planteamos el algoritmo de la forma:
<pre>
bb(ls,e) {
        r = -1;
	n = |ls|;
	(i,j) = (0,n);
	while(j-i >0){
	    k = (i+j)/2;
	    if(ls[k] == e){
	       r = k;
               break;	
            } else if(e < ls[k]){
	       (i,j) = (i,k);
	    } else {
               (i,j) = (k+1,j);
	    }
	}
        return r;
}
</pre>
<p>
Podemos comprobar que se cumple el invariante. Por otra parte la restricción de las salida es:
\[ ((r=-1 \land j-i= 0) \lor (r = k \land ls[k]= e)) \land I(i,j) \]
De lo que podemos deducir que el algortimo cumple su cometido.
</p>
El problema de la bandera holandes se enuncia así: <br>
<p>
Dada una lista y un elemento del mismo tipo que las casillas, que llamaremos pivote, reordenarla, 
de menor a mayor, para que resulten tres bloques: los menores que el pivote, los iguales al pivote y los mayores 
que el pivote. El algoritmo debe devolver dos enteros que son las posiciones de las casillas que separan 
los tres bloques formados. 
</p>
<p> Partimos de la lista \(ls\) de tamaño \( n = |ls|\) y el pivote \(e\). 
Escogemos el estado formado por la tupla \( (a,b,c) \) y el invariante que asegura que en la sublista \(ls[0,a]\) todos
los elementos son más pequeños que el pivote, en la sublista \(ls[a,b]\) todos
los elementos son iguales al el pivote, en la sublista \(ls[c,n]\) todos
los elementos son mayores que el pivote (elementos desconocidos) y en la sublista \(ls[b,c]\) la relación de los 
los elementos con  el pivote es desconocida. El tamaño del problema será \(b-c\) ya que cuando se va haciendo más pequeño
más reducida es la zona desconocida.
</pre>
Con los elementos anteriores se propone se siguiente algoritmo:
<pre>
bh(ls, p){
        (a,b,c) = (i,i,j);
	while(c-b>0){
		if(p < ls[b]){
		    it(a,b,ls);
		    a++;
		    b++;
		}else if(p == ls[b]){
		    b++;
		}else{
		    it(b,c-1,ls);
		    c--;
		}
	}
        return (a,b);
}

</pre>
Donde la función \(it\) intercambia los valores de las dos casillas \(a,b\) y es de la forma:
<pre>
it(a,b,ls){
	(ls[a],ls[b]) = (ls[b],ls[a]);
}
</pre>
Podemos comprobar que la función de cota se reduce en cada iteración y que se mantiene el invariante. 
Como vemos, escogemos la primera casilla de la zona de elementos desconocidos para ubicarlo en una de las tres zonas de
elementos conocidos. Cada vez que ubicamos uno disminuye \(b-c\) y por lo tanto el tamño del problema.
En el efecto en el caso \(p \lt ls[b]\) debemos intercambiar las casillas \(a,b\) para colocar el valor correspondiente 
en la zona \(0,a\). Aumentamos \(a, b\) en uno porque la primera zona ha aumentado en 1 y la zona tercera de elementos no conocidos ha disminuido en 1.
\(ls\)
</pre>
<h2> Una forma particular de algoritmo iterativo </h2>
</p>
Con mucha frecuencia se presenta un caso particular de algoritmo iterativo en la forma:
<pre>
f(x) {
	e = e_0;
	a = a_0;
	while(g(e)){	   
	   if(h(e){
	      r = t(e);
	      a = ac(a,r);
	   }
	   e = s(e);		   
        }
	return a;
}
</pre>
<p>
Aquí aparecen elementos nuevos: el acumulador \(a\), el filtro \(h(e)\), la transformación \(t(e)\) y 
la función de acumulación \(c(a,r)\).
Todo ello junto al estado \(e\), el estado inicial \(e_0\), la guarda \(g(e)\), y la función siguiente \(s(e)\).
Ahora \(e_0,s(e),g(e)\)  es la secuencia asociada al algoritmo, posteriormente filtrada por el predicado \(h(e)\), 
transformada por la función
\(t(e)\) y acumulada por la función de acumulación \(ac(a,r)\). 
La secuencia definida por el problema es de la forma:
\[ s = [t(x), x \in (e_0,s(e),g(e)) | h(x)] \]
El esquema algoritmico anterior acumula los valores de la secuencia combinándolos mediante al función 
\(ca(a,r)\) en la forma:
\[
c(...(c(c(a_0,t(e_0)),t(e_1))...,t(e_{m-1}))
\]
El algoritmo define una secuencia, un acumulador y un valor acumulado.
En definitiva el algoritmo genera la secuencia \(e_0,e_1,...,e_{m-1}\).  Esta es la secuencia más larga 
que partiendo de \(e_0\) y
aplicando \(s(e)\) podemos obtener de tal forma que todos sus elementos cumplan \(g(e)\). Luego
la filtra  y la transforma en 
\(t(e_0),t(e_1),...,t(e_m)\). Todos los elementos de secuencia filtrada cumplen 
\(g(e) \land h(e)\). Posteriormente acumula el resultado mediante un acumulador.
Un acumulador se especifica con un elemento inicial y una función binaria: \( A = (a_0, ac(a,e)) \). 
Aplicado a una secuencia produce un valor acumulado. A la secuencia vacía se le asigna un
valor acumulado de \(a_0\). Aplicar un acumulador a una secuencia lo indicamos \( Ac(sq, A) \). 
Por ejemplo \( \prod_{i=1}^n i \) 
acumula la secuencia \( [1,2,...,n] \) con el acumulador \( (1, \_*\_) \). El algoritmo
anterior define una acumulador y el valor acumulado devuelto es: 

\[ Ac(sq,A), sq = [ t(e) e \in (e0, s(e), p(e)) | h(e)], A =(a_0,ac(\_,\_)) \]
El invariante del algoritmo asegura que el valor del acumulador es igual al valor acumulado por el acumulador definido
por el algoritmo sobre la secuencia definida por él de una longitud igual al número de iteraciones.
</p>
<p>
Podemos considerar, de nuevo, el problema de la factorial visto arriba. Ahora siguiendo el esquema anterior podemos considerar
el factorial como la acumulación de un producto:

\[ n! = \prod_{i=1}^n i \]
Y si el valor para la secuencia vacía del acumulador anterior \( 0! = 1\). Con esas ideas el esquema anterior se concreta 
en un nuevo algoritmo para el factorial:

<pre>
f(n) {
	e = 1;
	a = 1;
	while(e < = n){	   
	   a = a * e;
	   e = e + 1;		   
        }
	return a;
}
</pre>
Podemos observar las pequeñas diferencias con el algoritmo del factorial visto arriba.  
La asignación paralela equivalente al cuerpo del bucle es \( (a,e) = (a*e,e+1) \). Ahora el invariante, que no hemos tenido que proponer,
es \( a = (e-1)!\).
Vemos que se cumple al comenzar el bucle. También que se mantiene en cada iteración. Si si hacemos la sustitución
simbólica correspondiente en el invariante:
\[ a*e = (e+1-1)! \equiv a*e = e! \equiv a*e = (e-1)!*e \equiv a = (e-1)! \]
Y la restricción entrada-salida deducida:
\[ r = a \land a = (e-1)! \land !(e < = n) \equiv r = a \land a = (e-1)! \land e = (n+1) \equiv r = n! \]
Es decir hubiéramos llegado a este algoritmo si hubiéramos escogido este invariante. Pero llegamos al algoritmo instanciando
el esquema algoritmico iterativo propuesto.

<h1><a id="#j8">Esquemas equivalentes en Java 8 a los Esquemas Iterativos</h1>
El esquema iterativo visto arriba:
<pre>
f(x) {
	e = e_0;
	a = a_0;
	while(g(e)){	   
	   if(h(e){
	      r = t(e);
	      a = ac(a,r); // o a.ac(r) si el acumulador es mutable
	      	           // if(p(a)) break; para algunos acumuladores
	   }
	   e = s(e);		   
        }
	return a;
}
</pre>
Tiene su equivalente en los Stream de Java 8 y en otros lenguajes actuales. 
<p>
Como ya comentamos aparecen: el acumulador \(a\), el filtro \(h(e)\), la transformación \(t(e)\) y 
la función de acumulación \(c(a,r)\).
Todo ello junto al estado \(e\), el estado inicial \(e_0\), la guarda \(g(e)\), y la función siguiente \(s(e)\).
Ahora \(e_0,s(e),g(e)\)  es la secuencia asociada al algoritmo, posteriormente filtrada por el predicado \(h(e)\), 
transformada por la función
\(t(e)\) y acumulada por la función de acumulación \(ac(a,r)\). 
La secuencia definida por el problema es de la forma:
\[ s = [t(x), x \in (e_0,s(e),g(e)) | h(x)] \]
El esquema algoritmico anterior acumula los valores de la secuencia combinándolos mediante al función 
\(ca(a,r)\).
</p>
Los elementos similares en Java 8 son:
<ul>
<li>
El tipo <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html"  target="_blank">Stream</a>
es el adecuado para representar secuencias de datos que pueden ser filtrados transformados y acumulados.
Existen versiones específicas para los tipos básicos como 
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/IntStream.html" target="_blank">IntStream</a>, etc.
Los elementos para trabajar con el tipo Stream son los de las secuencias en general:
<ul>
<li>
Secuencias básicas: <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/IntStream.html#range-int-int-" target="_blank">range(a,b)</a>,
 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#iterate-T-java.util.function.UnaryOperator-" target="_blank">iterate(e0,s(e))</a>, ...
</li>
<li>
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#filter-java.util.function.Predicate-" target="_blank">Filtro </a>
</li>
<li>
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#map-java.util.function.Function-" target="_blank">Transformación</a>
</li> 
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#collect-java.util.stream.Collector-" target="_blank">Acumulación</a>
</li>
</ul>
<li>
Un acumulador sobre un tipo mutable es una implementación de <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collector.html" target="_blank">Collector</a>
</li>
<li>
Una factoría de acumuladores podemos encontrar en <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html" target="_blank">Collectors</a>
</li>
<li>
Los acumuladores sobre tipos inmutables son métodos como 
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#allMatch-java.util.function.Predicate-" target="_blank">allMatch</a>, 
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#anyMatch-java.util.function.Predicate-" target="_blank">anyMatch</a>,
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#max-java.util.Comparator-" target="_blank">max</a>,
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#min-java.util.Comparator-" target="_blank">min </a>, 
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#reduce-T-java.util.function.BinaryOperator-" target="_blank">reduce(e0,b(x,y)) </a>,,...
</li>
</ul>
Veamos algunos ejemplos en Java 8 y su equivalente en al algoritmo iterativo visto arriba. 
<ul>
<li> Un número \(n\) es primo si no es divisible por ningún número en el rango \([2,\sqrt{n}]\). </li>
<li> El siguiente primo de un número \(n\)es el primero de la secuencia de impares mayores que \(n\)
filtrada por los que sean primos.</li>
<li> Los primos menores o iguales a \(n\) se forman acumulando la secuencia \([1,siguientePrimo(e),e \le n]\)
en una lista</li>
<li> La suma de los primos menores o iguales a \(n\) se forman sumando los elementos de la secuencia \([1,siguientePrimo(e),e \le n]\)</li>
</ul>
<pre>
    
	public static boolean esPrimo1(Long n){
		Long sqrt = (long)Math.sqrt((double)n);
		return !LongStream.rangeClosed(2, sqrt).anyMatch(x->Math2.esDivisible(n, x));
	}
	
	public static boolean esPrimo2(Long n){
		Long sqrt = (long)Math.sqrt((double)n);
		Long e = 2L;
		Boolean a = false;
		while(e <= sqrt){
			a = Math2.esDivisible(n, e);
	    	if(a) break; 
	    	e = e + 1;		   
		}
		return !a;
	}
	
	public static Long siguientePrimo1(Long n){
		Long e0 = n%2==0?n+1:n+2;
		return Stream.iterate(e0, e->e+2).filter(e->Math2.esPrimo(e)).findFirst().get();
	}
	
	
	public static Long siguientePrimo2(Long n){
		Long e = n%2==0?n+1:n+2;
		Long a = null;
		while(true){	   
			if(esPrimo2(e)) {
				a = e;
				break;
			}
			e = e +2;		   
		}
		return a;
	}
	
	public static List<Long> primosMenoresOIgualesA1(Long limit){
		return Stream2.iterate(1L, x->siguientePrimo1(x)).whilePredicate(x->x<=limit).collect(Collectors.toList());
	}
	
	public static List<Long> primosMenoresOIgualesA2(Long limit){
		Long e = 1L;
		List<Long> a = Lists.newArrayList();
		while(e<=limit){
			a.add(e);
			e = siguientePrimo2(e);		   
		}
		return a;
	}
	
	
	public static Long sumaPrimosMenoresOIgualesA1(Long limit){
		return Stream2.iterate(1L, x->siguientePrimo1(x)).whilePredicate(x->x<=limit).reduce(1L,(x,y)->x+y);
	}
	
	
	public static Long sumaPrimosMenoresOIgualesA2(Long limit){
		Long e = 1L;
		Long a = 0L;
		while(e<=limit){
			a = a+e;
			e = siguientePrimo2(e);
		}
		return a;
	}
</pre>

Otros ejemplos resueltos en Java 8 pueden encontrars en las clases 
<a href="../us/lsi/java8ejemplos/Ejemplos.html" target="_blank">Ejemplos</a> y <a href="../us/lsi/java8ejemplos/OtrosEjemplos.html" target="_blank">OtrosEjemplos</a>.


<h1><a id="rc"> Esquemas Recursivos </h1>

La definición recursiva de un problema es una especificación de la solución del mismo en base a la de otros 
problemas de la misma naturaleza pero de un tamaño más pequeño. 
Todo problema tiene un conjunto de propiedades y una solución. 
En toda definición recursiva aparecen los conceptos de caso base, caso recursivo y tamaño de un problema. 
Veamos para ir aclarando estos conceptos un ejemplo. 
Queremos definir el problema \( n! \) (factorial de n) y queremos hacerlo de forma recursiva. 
La definición es de la forma:
\[
n! =
\begin{cases}
1, & \text{si }n = 0 \\
n*n(n-1), & \text{si }n >0
\end{cases}

\]

La idoneidad de la definición podemos verla con un ejemplo:
\[
3!=3*2!=3*2*1!=3*2*1*0!=3*2*1
\]
<p>
Lo primero que debemos tener en cuenta es que cuando vamos a hacer una definición recursiva de un problema siempre 
debemos tener en cuenta un conjunto de problemas. 
Al conjunto de problemas los llamamos también dominio. En este caso el conjunto de problemas viene dado por todos 
los problemas del tipo \(n!\) para todo \(n>=0 \). 
</p>
<p>
En lo que sigue representaremos los problemas por \( p,p_1,p_2,…,p_r\). 
Un conjunto de problemas lo representaremos por P. Cada problema tendrá unas propiedades \(x\). 
Cada propiedad específica la representaremos mediante un superíndice: \(x=(x^1,…,x^m)\). 
Dentro de un conjunto de problemas \(P\) los valores de sus propiedades identifican al problema de manera única.
Un problema podemos pensarlo como un objeto.
El dominio, \(D(x)\), es una expresión válida para las propiedades de todos los problemas 
que están incluidos en el conjunto de problemas de interés. 
A cada problema podemos asociar el concepto de tamaño que es una nueva propiedad derivada del mismo. 
Normalmente representaremos el tamaño de un problema mediante \(n\) 
y lo calcularemos mediante una función sobre las propiedades del mismo. Lo representamos por \(n=n(x)\) o \(n=n(p)\). 
El tamaño del problema deber ser un entero mayor o igual que cero que nos dé una idea de la complejidad del mismo. 
Problemas de tamaño mayor serán más complejos que otros de tamaño menor. 
Puede haber distintas formas para escoger el tamaño de un problema. 
Dentro de un conjunto de problemas aquellos que tienen una solución directa los llamamos casos base. 
Estos suelen tener un tamaño pequeño. En el conjunto de problemas \(n!,n \ge 0\) el problema \(0!\) es un caso base. 
Su solución es 1. Puede haber más de un caso base. El resto de problemas del conjunto considerado 
(en este caso todos los que tienen \(n>0\)) los denominaremos casos recursivos. 
</p>
La solución de un caso recursivo se define en función de la de otros problemas de tamaño menor. 
Estos los denominaremos sub-problemas. Un mismo problema puede tener diferentes definiciones recursivas. Otra definición recursiva para la factorial es:

\[
n! =
\begin{cases}
1, & \text{si }n = 0 \\
1, & \text{si }n = 1 \\
n*n(n-1), & \text{si }n >1
\end{cases}

\]

En este caso hay dos casos base. Y otra más es:
\[
n! = f(n,1)
\]
\[
f(n,a) =
\begin{cases}
a, & \text{si }n = 0 \\
f(n-1,n*a), & \text{si }n >0 \\
\end{cases}

\]

Esta última definición recursiva es menos evidente pero, como veremos más adelante, importante. 
Ahora el conjunto de problemas es \((n,a),n \ge 0,a \ge 1\). Con esa última 
definición la solución del problema original, \(n!\), es igual la del problema \(fa(n,1)\). 
Es decir hemos definido la solución del problema \(n!\), que tiene una sola propiedad, en base a otro que tiene dos: 
\(fa(n,m)\). A este proceso se le llama generalización y es el mecanismo adecuado para colocar un problema 
a resolver dentro de un conjunto de problemas necesario para la definición recursiva.
El tamaño del problema \(n!\) es \(n\) y el de \((n,m)\) también es \(n\). 

Podemos comprobar con un ejemplo que la definición es adecuada. En efecto:
\[
3!=(3,1)=(2,3*1)=(1,2*3*1)=(0,1*2*3*1)=1*2*3*1
\]

Pero no todas las definiciones recursivas son adecuadas para construir un algoritmo. 
Para que una definición recursiva pueda convertirse en un algoritmo debe tener al menos un caso base
y cada caso recursivo definirse en base a otro u otros de menor tamaño. 
Las siguientes son propiedades de la factorial.
\begin{cases}
0! = 1\\
\frac{(n+1)!}{n+1} = n! \\
\end{cases}
<p>
Pero juntas no forman un algoritmo recursivo. Las definiciones anteriores no constituyen
 un algoritmo porque el caso recursivo se ha definido en base a otros problemas de tamaño mayor. 
En un algoritmo es necesario que los sub-problemas usados para definir el caso recursivo tengan un tamaño menor. 
Así en cada paso recursivo (paso de un problema a los sub-problemas que lo definen) se reduce el tamaño. 
Como éste deber ser mayor o igual a cero para todos los problemas del conjunto considerado en algún momento 
llegaremos al caso base y el algoritmo acabará. Esto no ocurre en la definición incorrecta anterior.
</p>
El algoritmo que podemos deducir de la definición anterior es: 

<pre>
f(n) {
	if(n==0){
		r = 1;
	} else {
		r = n*f(n-1);
	} 
	return r;
}
</pre>
<p>
Este algoritmo recursivo es la transcripción mimética de la primera definición recursiva que dimos para la factorial. 
Las otras definiciones tienen algoritmos similares. 
</p>
El esquema general de un algoritmo recursivo es:
<pre>
f(x) {
	if(b(x)){
		s = sb(x);
	} else {
		y_1 = sp_1(x);
		s_1 = f(y);
		y_2 = sp_2(x);
		s_2 = f(y2);
		...
		s = c(s_1,s_2,...,x);
	} 
	return s;
}
</pre>
El un algoritmo recursivo aparecen los siguinetes conceptos:
<ul>
<li> b(x): Es una función lógica que devuelve verdadero si el problema es un caso base </li>
<li> sb(x): Es una función que devuelve la solución del caso base. </li>
<li> sp_1(x), sp_2, ...:Son funciones que calculan los sub-problemas al que se reduce el problema original. </li>
<li> c(s,x): Es una función, que llamaremos función de combinación, que obtiene la solución del problema
combinando las soluciones de los sub-problemas con las propiedades del problema. </li>
</ul>
<p>
La recursividad puede ser de diferentes tipos. 
En primer lugar la vamos a clasificar según el número de sub-problemas 
en recursividad simple (también llamada recursividad lineal) cuando el número de sub-problemas es uno y 
recursividad múltiple cuando el número de sub-problemas es mayor que uno. Un ejemplo de recursividad múltiple
es la definición de los números de Fibonacci.
\[
fib(n) =
\begin{cases}
n, & \text{si }n <= 1 \\
f(n-1)+fib(n-2), & \text{si }n >1 \\
\end{cases}

\]
</p>
En muchos algoritmos recursivos como el anterior se repiten muchos subproblemas lo que hace que el algoritmo
tarde más en ejecutarse.
Para evitar los cálculos repetidos podemos mejorar es esquema recursivo anterior (que lo denominamos 
divide y vencerás)
intentando recordar los cálculos ya realizados. 
Para ello diseñamos un nuevo algoritmo recursivo que llamaremos divide y vencerás con memoria 
(en anterior era divide y vencerás sin memoria). 
Para ello necesitamos una variable \(m\),   de tipo diccionario,
que guarde la solución \(s\) para cada problema \(x\) ya resuelto. 

El esquema es:
<pre>
f(x) {
	if(x en m.keys()) {
		s = m[x];
	} else if(b(x)){
		s = sb(x);
		m[x] = s;
	} else {
		y_1 = sp_1(x);
		s_1 = f(y1);
		y_2 = sp_2(x);
		s_2 = f(y2);
		...
		s = c(s_1,s_2,...,x);
		m[x] = s;
	} 
	return s;
}
</pre>

<a id="itrc"><h1>Transformación Iterativo-Recursivo final y viceversa </h1>

El algoritmo iterativo:
<pre>
f(x) {
	e = e_0;
	a = a_0;
	while(g(e)){	   
	   if(h(e){
	      r = t(e);
	      a = ac(a,r);
	   }
	   e = s(e);		   
    }
	return a;
}
</pre>
Tiene la siguiente versión recursiva:

\[ f(x) = fr(a_0,e_0) \]
\[ fr(a,e) = 
\begin{cases}
a, & \text{si } !g(e) \\
fr(c(a,t(e)),s(e)), & \text{si } g(e) \land h(e) \\
fr(a,s(e)), & \text{si } g(e) \land !h(e) \\
\end{cases}
\]
El algoritmo recursivo resultante es de recursividad simple y final. Simple porque tiene una sola llamada recursiva. 
Final porque el resultado es igual al de la llamada recursiva sin ninguna operación posterior.
A la inversa también es cierto. Un algoritmo recursivo final tiene una versión iterativa equivalente. Así la definición 
recursiva final:
\[ f(e) = 
\begin{cases}
r(e), & \text{si } !g(e) \\
fr(s(e)), & \text{si } g(e) \\
\end{cases}
\]
El esquema recursivo previo es un caso particular de este más general. Para ver la equivalencia hagamos \( e = (a,e_1) \)
 y la función siguiente de la forma:
\[ s(a,e_1) = 
\begin{cases}
s(c(a,t(e_1)),s_1(e_1)), & \text{si } h(e_1) \\
s(a,s_1(e_1)), & \text{si } !h(e_1) \\
\end{cases}
\]
El último esquema recursivo tiene el equivalente iterativo:
<pre>
fe(e) {
	while(g(e)){	   
	   e = s(e);	   
    }
	return r(e);
}
</pre>
Vemos, pues, que el esquema recursivo final, y su equivalente iterativo definen una secuencia definida por el primer
valor de \( e\) y al sucesiva aplicación de \( s(e) \) mientras que se cumpla \(g(e) \).
Veamos como ejemplo el algoritmo recursivo para el maximo común divisor que podemos derivar de las propiedades del mismo:
\[
\begin{cases}
mcd(a,b) = mcd(b,a) \\
mcd(a,0) = a \\
mcd(a,b) = mcd(b,a%b)
\end{cases}
\]
Escogiendo como tamaño del problema \( t(a,b) = b \) llegamos al algoritmo recursivo:
\[
mcd(a,b) =
\begin{cases}
a, & \text{si } b = 0 \\
mcd(b,a\%b), & \text{si } b >0
\end{cases}
\]
Que, como vemos, es recursivo final y por lo tanto admite la versión iterativa:

<pre>
mcd(a,b) {
	while(b > 0){	   
	   (a,b) = (b,a%b)	   
        }
	return a;
}
</pre>
<a id="rcit"><h1>Transformación Recursivo-Iterativo </h1>
<p>
Como hemos visto en la sección anterior los algortimos recursivos finales tienen sus equivalentes iterativos. 
Los algoritmos recursivos generales pueden, en algunos casos, tranformarse a recursivos finales. 
Veamos dos aproximaciones: una para algortimos recusivos simples no finales cuyo operador de combinación tiene algunas
propiedades, otra para algoritmos recursivos múltiples con algunas características determinadas.
</p>
<h3> Transformación de recursivo simple a iterativo con acumulador </h3>
<p>
Un algoritmo recursivo simple tiene la forma:
\[
f(e) =
\begin{cases}
sb(e), & \text{si } b(e) \\
c(f(s(e),e), & \text{si } !b(e) \\
\end{cases}
\]
Como dijimos arriba el operador \( c(a,e) \) se denomina operador de combinación. Si \(e_0\) es el primer valor de \(e\)
y \(e_b \) el caso base entonces el algoritmo define una secuencia \( [e_0,s(e_0),...e_{m-1},e_b] \). 
En esa secuencia todos los elementos cumplen el predicado \( g(e) \) salvo el caso base \( e_b \). El algoritmo acumula
los valores de la secuencia \( [e_0,s(e_0),...e_{m-1}] \) con el acumumulador \( (sb(e_b), c(a,e) ) \). 
Pero hace la acumulación de derecha a izquierda a diferencia del esquema recursivo final que hacía la acumulación
de izquierda a derecha. Si la función de combinación cumple las propiedades:
<ul>
<li> Sea asociativa. Es decir \( c(a_1,c(a_2,e)) = c(c(a1,a2),e) \) </li>
<li> Tenga un elemento neutro, \(a_0 \), por la izquierda.  
Es decir \( c(a_0,e) = e \) </li>
<li>
\(sb(e_b)\) sea un elemento neutro por la derecha. Es decir \( c(a,sb(e_b)) = a \)
</li>
</ul>
El resultado de acumular la secuencia por la derecha será igual que acumularla por la izquierda con el correspondiente
elemento neutro por la izquierda. En ese caso el esquema anterior es equivalente al recursivo final:
\[
f(e) = fr(a_0,e) = 
\begin{cases}
a, & \text{si } b(e) \\
fr(c(a,e),s(e)), & \text{si } !b(e) \\
\end{cases}
\]
Que como sabemos tiene el equivalente iterativo:
<pre>
f(x) {
	(a,e) = (a_0, x);
	while(!b(e)){	   
	   (a,e) = (c(a,e),s(e));	   
        }
	return a;
}
</pre>
Si \(sb(e_b)\) no fuera un elemento neutro por la derecha de \( c(a,e) \) entonces el esquema recursivo final equivalente
es ligeramente diferente:
\[
f(e) = fr(a_0,e) = 
\begin{cases}
c(a,sb(e)), & \text{si } b(e) \\
fr(c(a,e),s(e)), & \text{si } !b(e) \\
\end{cases}
\]
Y su  equivalente iterativo:
<pre>
f(x) {
	(a,e) = (a_0, x);
	while(!b(e)){	   
	   (a,e) = (c(a,e),s(e));	   
        }
	return c(a,sb(e));
}
</pre>
Hay casos en que la transformación anterior no es posible pero podemos imaginar otra solución al problema donde si lo sea.
La potencia entera es el cálculo de \(b^n \) donde \( n \) es un entero no negativo. Según usemos algunas propiedades 
u otras resultará un algoritmo para su cálculo:
El primer algoritmo se basa en las propiedades de la potencia entera. Dos difiniciones posibles son:
\[
b^n =
\begin{cases}
1, & \text{si } n = 0 \\
b^{n-1}*b, & \text{si } n \gt 0
\end{cases}
\]

\[
b^n =
\begin{cases}
1, & \text{si } n = 0 \\
(b^{n/2})^2*b, & \text{si } n\%2 = 1 \\
(b^{n/2})^2, & \text{si } n\%2 = 0
\end{cases}
\]
La primera permite una transformación a recursivo final si consideramos la secuencia \( [n,n-1,...,i, ..., 1] \), 
la función de transformación \(t(i) = b \) y el operador 
de acumulación \( (1,a*e) \). En la segunda definición la función de combinación es: 
\[
c(a,n) =
\begin{cases}
a^2*b, & \text{si } n\%2 = 1 \\
a^2, & \text{si } n\%2 = 0
\end{cases}
\]

Esta función no cumple los requisitos de asociatividad, etc. No podemos aplicar el método anterior. Pero podemos 
pensar en una tercera definición basada en la descomposición en binario del exponente:

\[
\begin{cases}
b^n & =  b^{\sum_{0}^{p} d_i 2^i} \\
& =  \prod_{0}^{p} b^{d_i 2^i} \\
& =  \prod_{0}^{p} (b^{2^i})^{d_i}
\end{cases}

\]

Los sucesivos dígitos de la representación en binario de \(n\) son iguales a \(n\%2\) y los valores de \(n\) 
siguen la secuencia \(n,n/2,n/4,...\). Podemos observar que 
\[ 
\prod_{0}^{p} (b^{2^i})^{d_i}
\]
puede ser considerado como la acumulación, mediante el acumulador \((1,a*e)\),
de la secuencia \([b^{2^0},b^{2^1},b^{2^2},...]\) filtrada para \( n\%2 = 1 \).  En efecto para 
\( n\%2 = 1, d_i = 1, (b^{2^i})^{d_i} = b^{2^i} \) y para \( n\%2 = 0, d_i = 0, (b^{2^i})^{d_i} = 1\). 
 A su vez en la secuencia \([b^{2^0},b^{2^1},b^{2^2},...]\) cada elemento es el cuadrado
del anterior con un primer elemento igual a \(b\). Si representamos los elementos de la secuencia por \(e\) tenemos una secuencia
de pares \(e,n\) definida por  \([(b,n),s(e,n) = (e^2,n/2), ...]\). El algortimo iterativo queda:
<pre>

pot(b,n){
	e = b;
	a = 1;
	while( n > 0){
        	if(n%2==1){
		     a = a * e;
		}
		e = e * e;
		n = n/2;
	}
	return a;
}


</pre>
<h3> Aproximación de abajo arriba </h3>
En segundo lugar veremos como transformar algunos problemas recursivos (múltiples o simples) en iterativos. 
El esquema recursivo general con \(k\) sub-problemas es:

\[ 
f(x) =
\begin{cases}
sb(x), & \text{si } b(x) \\
c(f(sp_0(x),f(sp_1(x),...,f(sp_{k-1}(x),x), & \text{si } !b(x)
\end{cases}
\]
<p>
La idea es generalizar el problema incorporando el tamaño del problema y las soluciones de calculadas de algunos subproblemas de tamaño menor, 
establecemos un invariante sobre  el estado elegido
y usamos las técnicas de diseño iterativo. Para ello hacemos que el invariante se cumpla para los casos base y vamos
aumentando, el el programa iterativo, el tamaño de los problemas hasta llegar al problema original.
La versión recursiva final se puede obtener de la versión iterativa.
</p>
Veamos como ejemplo el problema de Fibonacci

\[ 
fib(n) =
\begin{cases}
n, & \text{si } n \le 1 \\
fib(n-1)+fib(n-2), & \text{si } n \gt 1
\end{cases}
\]

Definimos el problema generalizado, el estado del algoritmo iterativo, con las propiedades \( e = (i,a,b) \)
y  establecemos el invariante \( a=fib(i+1), b=fib(i) \). 
El problema final es \( i=n \). Un problema inicial que cumple el invariante es (0,1,0).  
Decidimos incrementar en cada paso la variable \( i \) en \(1\). 
Pretendemos deducir del invariante y del incremento decididido para  \(i\) la función \( s(e) \). Tenemos
\[
\begin{cases}
(i',a',b') & = (i',fib(i'+1),fib(i') \\
& =  (i+1,fib(i+2),fib(i+1) \\
& =  (i+1,fib(i+1)+fib(i),fib(i+1) \\
& =  (i+1,a+b,a) \\
\end{cases}
\]


Y de aquí el esquema resultante  es:

<pre>
fib(n){
	(i,a,b) = (0,1,0);
	while(i < n){
		(i,a,b) = (i+1,a+b,a);
	}
	return b;
}
</pre>
Desplegando la asignación paralela
<pre>
fib(n){
	i = 0;
        a = 1;
	b = 0;
	while(i < n){
		i = i+1;
		a0 = a;
		a = a0+b;
		b = a0;
	}
	return b;
}
</pre>
La idea anterior se puede generalizar a un conjunto variable de subproblemas.  
En ese caso es mejor usar un dicionario para guardar las soluciones. 
Veamos como ejemplo de este caso el cálculo del número
combinatorio \( \binom{n}{k} \). Los números combinatorios tienen las propiedades:

\[

\begin{cases}
\binom{n}{0} = \binom{n}{n} = 1, & \text{si } n \ge 0 \\
\binom{n}{1} = \binom{n}{n-1} = 1, & \text{si } n \ge 1 \\
\binom{n}{k} = \binom{n}{n-k} = 1, & \text{si } n \ge k \\
\binom{n}{k} + \binom{n}{k+1} = \binom{n+1}{k+1}, & \text{si } n \ge k \\
\end{cases}

\]

Escogiendo como tamaño \(min(k,n-k)\) tenemos la definición recursiva:

\[
\binom{n}{k} =
\begin{cases}
1, & \text{si } k = 0 \lor k = n\\
n, & \text{si } k = n  \lor k = n-1\\
\binom{n-1}{k-1} + \binom{n-1}{k}, & \text{en otro caso}\\
\end{cases}

\]
Es esquema iterativo equivalente comienza con los casos base y va calculando todos los problemas 
de tipo \(\binom{i}{k}\) para los valores posibles de \(k \in [0,n]\) 
a partir de las soluciones de los problemas con \(\binom{i-1}{k}\). Hay \( n+1\) problemas del tipo \( \binom{i}{k} \)
cuyas soluciones se pueden guardan en una lista.
Va incrementando uno a uno el valor de \(i\) hasta alcanzar \(n\). El esquema iterativo es:

<pre>
binom(n,k) {
	lsa = [1];
	i = 1;
	while(i <= n) {              
		ls = [];
		for(s=0;s<=i;s++){			
			if(s == 0 || s == i) {
				ls = ls + 1;
			else if(s==1 || s == i-1){
				ls = ls + i;
			} else {
			     	ls = ls + (lsa[s-1]+lsa[s]);
			}
		}
		i = i +1;
		lsa = ls;
	}
        return lsa[k];
}
</pre>

</body>
</html>